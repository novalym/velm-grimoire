# =================================================================================
# == GNOSTIC ARCHETYPE: QUANTUM PULSE SYNC (V-Î©-TOTALITY)                       ==
# =================================================================================
# @description: Materializes a high-availability distributed coordination layer. Implements Leader Election and Multi-Node Heartbeats via Redis to ensure only one "Oracle Prime" conducts writes in a distributed multiverse.
# @category: System
# @tags: consensus, leader-election, distributed-systems, redis, synchronization, heartbeat
# @difficulty: Grand Architect
# @is_integration: true
# @dna: redis_db=2, lease_duration=10, check_interval=2, auto_failover=true
# =================================================================================

# --- I. THE ALTAR OF GNOSTIC WILL ---
$$ redis_url = "redis://reactive-backbone:6379/2"
$$ lease_ms = 10000
$$ package_name = {{ package_name | default(project_slug | snake) }}

# --- II. THE CONSENSUS CORE (Logic Stratum) ---
src/{{ package_name }}/
    core/
        consensus/
            __init__.py :: "from .leader import PulseLeaderElect"
            
            # [1] THE LEADER ELECTION ENGINE
            leader.py :: """
            import asyncio
            import uuid
            import time
            import logging
            from redis.asyncio import Redis
            from typing import Optional, Callable, Awaitable

            Logger = logging.getLogger("QuantumPulse:Consensus")

            class PulseLeaderElect:
                \"\"\"
                =============================================================================
                == THE PULSE LEADER (V-Î©-CONSENSUS-GUARD)                                  ==
                =============================================================================
                LIF: âˆž | ROLE: CONSENSUS_CONDUCTOR | RANK: OMEGA
                
                Ensures that among many nodes, only one is willed to be 'Prime'.
                \"\"\"
                def __init__(self, redis: Redis, identity: Optional[str] = None):
                    self.redis = redis
                    self.id = identity or f"node-{uuid.uuid4().hex[:6]}"
                    self.key = "velm:leader:prime"
                    self.is_prime = False
                    self._task: Optional[asyncio.Task] = None

                async def ignite(self, on_ascension: Callable[[], Awaitable[None]]):
                    \"\"\"Begins the struggle for Sovereignty.\"\"\"
                    Logger.info(f"ðŸŒ€ Node {self.id} entering the struggle for leadership...")
                    self._task = asyncio.create_task(self._election_loop(on_ascension))

                async def _election_loop(self, on_ascension):
                    while True:
                        try:
                            # 1. Attempt to claim the Lease
                            # NX=True: Only set if not exists
                            # PX: Set expiration in milliseconds
                            acquired = await self.redis.set(
                                self.key, self.id, px={{ lease_ms }}, nx=True
                            )

                            if acquired:
                                if not self.is_prime:
                                    self.is_prime = True
                                    Logger.success(f"ðŸ‘‘ ASCENSION: Node {self.id} is now PRIME.")
                                    await on_ascension()
                            else:
                                # 2. Verify current leader
                                current_leader = await self.redis.get(self.key)
                                if current_leader == self.id:
                                    # We are already leader, renew lease
                                    await self.redis.pexpire(self.key, {{ lease_ms }})
                                    self.is_prime = True
                                else:
                                    if self.is_prime:
                                        Logger.warning(f"ðŸŒ‘ DEPOSITION: Node {self.id} has lost Sovereignty.")
                                    self.is_prime = False

                        except Exception as e:
                            Logger.error(f"Consensus Fracture: {e}")
                            self.is_prime = False
                        
                        await asyncio.sleep(2) # Polling interval

                async def dissolve(self):
                    \"\"\"Gracefully relinquish leadership.\"\"\"
                    if self.is_prime:
                        await self.redis.delete(self.key)
                    if self._task:
                        self._task.cancel()
            """

# --- III. THE MAESTRO'S WILL ---
%% post-run
    proclaim: "The [bold cyan]Quantum Pulse Sync[/bold cyan] is manifest."
    proclaim: "Distributed Consensus logic established in 'core/consensus/'."
    
    # 1. Dependency Verification
    proclaim: "Ensuring Redis-py is manifest for gRPC/Consensus..."
    >> poetry add redis
    ?? succeeds

    proclaim: "[bold green]âœ… Consensus Engine Active.[/bold green]"
    proclaim: "Node Identity: [magenta]Auto-generated UUID[/magenta]"

%% on-heresy
    proclaim: "Consensus inception failed. Purging shards..."
    rm -rf src/{{ package_name }}/core/consensus